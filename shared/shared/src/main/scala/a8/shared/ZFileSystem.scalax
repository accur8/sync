package a8.shared

import a8.shared.SharedImports._
import a8.shared.ops.IteratorOps
import zio.{Task, ZIO}

import java.io._
import java.nio.file.attribute.BasicFileAttributes
import java.nio.file.{Files, LinkOption, Paths, Path => NioPath}
import java.time.LocalDateTime
import scala.util.Try

object ZFileSystem {

  lazy val userHome: Task[Directory] = dir(System.getProperty("user.home"))

  trait Path {
    def name: String
    def canonicalPath: Task[String]
    def absolutePath: Task[String]
    def exists: Task[Boolean]
    def moveTo(d: Directory): Task[Unit]
    def copyTo(d: Directory): Task[Unit]
    def relativeTo(directory: Directory): Task[String] =
      for {
        nioDir <- directory.asNioPath
        nioThis <- asNioPath
        result <- zioDefer(nioDir.relativize(nioThis).toString)
      } yield result
    def asNioPath: Task[NioPath]
    def kind: String
    def delete: Task[Unit]
    def parentOpt: Task[Option[Directory]]
    protected def realToString: String
    override def toString = realToString
  }

  trait Directory extends Path {
    def parentOpt: Task[Option[Directory]]

    def \(fileName: String): File = file(fileName)
    def \\(subdirName: String): Directory = subdir(subdirName)

    /**
     * makes sure the directory exists
     * @return
     */
    def resolve: Task[Directory] =
      for {
        e <- exists
        _ <-
          if (e) zunit else makeDirectories
      } yield this

    def makeDirectories: Task[Unit]
    def makeDirectory: Task[Unit]
    def subdirs: XStream[Directory]
    def entries: XStream[Path]
    def files: XStream[File]
    def deleteChildren: Task[Unit]
    def file(filename: String): File
    def subdir(subdirName: String): Directory

  }

  trait File extends Path {

    def parent: Directory
    def write(content: String): Task[Unit]
    def write(is: InputStream): Task[Unit]
    def withInputStream[A](fn: InputStream => A): Task[A]
    def withReader[A](fn: Reader => A): Task[A]
    def appendWithOutputStream[A](fn: OutputStream => A): Task[A]
    def withOutputStream[A](fn: OutputStream => A): Task[A]
    def withPrintStream[A](fn: PrintStream => A): Task[A]
    def size: Task[Long]
    def lastModified: Task[Long]

    def readAsString: Task[String] = {
      withReader(_.readFully())
    }

    def readBytes: Task[Array[Byte]] = {
      withInputStream(_.readAllBytes())
    }

    /**
     * reads the file as a string if it exists
     * returns None if it doesn't exist
     */
    def readAsStringOpt: Task[Option[String]] =
      for {
        e <- exists
        result <-
          if (e) readAsString.map(_.some)
          else zsucceed(None)
      } yield result

    def copyTo(target: File): Task[Unit] = zioDefer {
      import java.nio.file.StandardCopyOption.REPLACE_EXISTING
      import java.nio.file.{Files, Paths}
      import language.implicitConversions
      for {
        thisPath <- asNioPath
        targetPath <- target.asNioPath
        _ <- zioDefer(Files.copy(thisPath, targetPath, REPLACE_EXISTING))
      } yield ()
    }
  }

  def dir(path: String): Task[Directory] = {
    val startingPath = Paths.get(path)
    realize(startingPath)
      .flatMap {
      case Right(d: Directory) =>
        zsucceed(d)
      case Right(p) =>
        ZIO.fail(new RuntimeException(s"expected a directory got a ${p.kind} -- ${p}"))
      case Left(np) =>
        zsucceed(new DirectoryImpl(np))
    }
  }

  def file(path: String): Task[File] = {
    realize(Paths.get(path))
      .flatMap {
      case Right(f: File) =>
        zsucceed(f)
      case Left(np) =>
        zsucceed(new FileImpl(np))
      case Right(p) =>
        ZIO.fail(new RuntimeException(s"expected a file got a ${p.kind} -- ${p}"))
    }
  }

  def fromNioPath(nioPath: NioPath): Task[Option[Path]] =
    realize(nioPath)
      .map(_.toOption)

  /**
   * returns a path of the correct type if it exists otherwise None
   */
  def path(path: String): Task[Option[Path]] =
    realize(Paths.get(path))
      .map(_.toOption)

  private def realize(path: NioPath): Task[Either[NioPath,Path]] = zioDefer {
    if ( path.exists() )
      new RealizedNioPath(path.toRealPath(LinkOption.NOFOLLOW_LINKS))
        .resolvePath()
    else {
      Left(path.toAbsolutePath.normalize())
    }
  }

  /**
   * calls to this method should ensure that the passed in path is absolute and normalized
   */
  private def unsafeRealize(path: NioPath): RealizedNioPath = {
    assert ( path.isAbsolute )
    new RealizedNioPath(path)
  }

  private def throwUnsupported(): Nothing = sys.error("this feature is currently not supported")

  /**
   * a RealizedNioPath is a java.nio.file.Path that has been returned by java.nio.file.Path.toRealPath(LinkOption.NOFOLLOW_LINKS)
   */
  private class RealizedNioPath(val nioPath: NioPath) extends AnyVal {
    def resolvePath(): Either[NioPath,Path] =
      Files
        .exists(nioPath)
        .toOption {
          val attributes = readAttributes(nioPath)
          if ( attributes.isRegularFile ) {
            new FileImpl(nioPath, None)
          } else if ( attributes.isDirectory ) {
            new DirectoryImpl(nioPath, None)
          } else if ( attributes.isSymbolicLink ) {
            new SymlinkImpl(nioPath)
          } else if ( attributes.isOther ) {
            new OtherPathImpl(nioPath)
          } else {
            sys.error(s"${nioPath} don't know how to handle attributes ${attributes}")
          }
        }
        .toRight(nioPath)
  }


  def fileSystemCompatibleTimestamp(): String = {
    val now = LocalDateTime.now()
    f"${now.getYear}-${now.getMonthValue}%02d-${now.getDayOfMonth}%02d_${now.getHour}%02d-${now.getMinute}%02d-${now.getSecond}%02d"
  }

  private def readAttributes(nioPath: NioPath): BasicFileAttributes =
    Files.readAttributes[BasicFileAttributes](nioPath, classOf[BasicFileAttributes])

  private abstract class PathImpl(
    val asNioPath: java.nio.file.Path,
  ) {

    lazy val name: String =
      asNioPath.getFileName.toString

    def canonicalPath: String =
      asNioPath.toString

    def attributes(): BasicFileAttributes =
      readAttributes(asNioPath)

    override def equals(obj: Any): Boolean =
      obj match {
        case p: Path =>
          p.canonicalPath === canonicalPath
      }

    override lazy val hashCode = canonicalPath.hashCode

  }

  private class OtherPathImpl(
    nioPath: NioPath,
  )
    extends PathImpl(nioPath)
    with Path
  {

    override def delete(): Unit = Files.delete(nioPath)

    override def exists(): Boolean =
      Try(readAttributes(nioPath).isOther)
        .getOrElse(false)

    override def moveTo(d: Directory): Unit = throwUnsupported()
    override def copyTo(d: Directory): Unit = throwUnsupported()
    override def kind: String = "other"
  }

  private class SymlinkImpl(
    nioPath: NioPath,
  )
    extends PathImpl(nioPath)
    with Path
  {

    override def delete(): Unit = Files.delete(nioPath)

    override def exists(): Boolean =
      Try(readAttributes(nioPath).isOther)
        .getOrElse(false)

    override def moveTo(d: Directory): Unit = throwUnsupported()
    override def copyTo(d: Directory): Unit = throwUnsupported()
    override def kind: String = "symlink"
  }

  private class FileImpl(
    nioPath: java.nio.file.Path,
    preloadedParent: Option[Directory] = None,
  )
    extends PathImpl(nioPath)
    with File
  {

    override def kind: String = "file"

    override lazy val parent: Directory =
      preloadedParent.getOrElse(new DirectoryImpl(nioPath.getParent))

    override def delete(): Unit =
      Files.delete(nioPath)

    override def exists(): Boolean =
      nioPath.toFile.exists()

    override def size(): Long =
      nioPath.toFile.length()

    override def write(content: String): Unit =
      withPrintStream(_.print(content))

    override def lastModified(): Long =
      nioPath.toFile.lastModified()

    override def withInputStream[A](fn: InputStream => A): A = {
      val is = new FileInputStream(nioPath.toFile)
      try {
        fn(is)
      } finally {
        is.close()
      }
    }

    override def withReader[A](fn: Reader => A): A = {
      val reader = new FileReader(nioPath.toFile)
      try {
        fn(reader)
      } finally {
        reader.close()
      }
    }

    override def write(is: InputStream): Unit = {
      try {
        withOutputStream { out =>
          val buffer = new Array[Byte](8192)

          def readNextOpt(): Option[(Array[Byte],Int)] = {
            is.read(buffer) match {
              case -1 =>
                None
              case i =>
                Some(buffer -> i)
            }
          }

          IteratorOps
            .wrap(() => readNextOpt())
            .foreach { case (buffer, count) =>
              if ( count > 0 ) {
                out.write(buffer, 0, count)
              }
            }

        }
      } finally {
        Try(is.close())
      }
    }

    override def withPrintStream[A](fn: PrintStream => A): A = {
      val fos = new FileOutputStream(nioPath.toFile)
      try {
        val out = new PrintStream(new FileOutputStream(nioPath.toFile))
        fn(out)
      } finally {
        Try(fos.close())
      }
    }

    override def withOutputStream[A](fn: OutputStream => A): A =
      withOutputStreamImpl(fn, false)

    def withOutputStreamImpl[A](fn: OutputStream => A, append: Boolean): A = {
      val fos = new FileOutputStream(nioPath.toFile, append)
      try {
        fn(fos)
      } finally {
        Try(fos.close())
      }
    }

    override def appendWithOutputStream[A](fn: OutputStream => A): A =
      withOutputStreamImpl(fn, true)

    override def moveTo(d: Directory): Unit =
      Files.move(asNioPath, d.file(name).asNioPath)

    override def copyTo(d: Directory): Unit =
      Files.copy(asNioPath, d.file(name).asNioPath)

  }


  private class DirectoryImpl(
    nioPath: NioPath,
    preloadedParent: Option[Directory] = None,
  )
    extends PathImpl(nioPath)
    with Directory
  {

    override def kind: String = "dir"

    override def parentOpt: Option[Directory] =
      preloadedParent
        .orElse {
          Option(nioPath.getParent)
            .map(p => new DirectoryImpl(p))
        }

    override def file(fileName: String): File =
      new FileImpl(nioPath.resolve(fileName).toAbsolutePath, Some(this))

    override def subdir(subdirName: String): Directory =
      new DirectoryImpl(nioPath.resolve(subdirName).toAbsolutePath, Some(this))

    override def moveTo(d: Directory): Unit =
      Files.move(asNioPath, d.subdir(name).asNioPath)

    override def makeDirectories(): Unit =
      Files.createDirectories(nioPath)

    override def makeDirectory(): Unit =
      Files.createDirectory(nioPath)

    override def subdirs: XStream[Directory] =
      entries
        .collect {
          case d: Directory => d
        }

    override def entries: XStream[Path] = {
      Files
        .list(nioPath)
        .iterator()
        .asScala
        .flatMap(p => unsafeRealize(p).resolvePath().toOption) // ??? this could be optimized to house the provide the parent path
        .to(Iterable)
    }

    override def files: XStream[File] =
      entries
        .collect {
          case f: File => f
        }


    override def deleteChildren: Task[Unit] = {
      entries
        .foreach(_.delete)
    }

    override def delete: Task[Unit] = {
      deleteChildren
      nioPath.toFile.delete()
    }


    override def copyTo(d: Directory): Task[Unit] = {
      for {
        targetDir <- zioDefer(d.subdir(name))
        _ <- targetDir.makeDirectories
        _ <- entries.foreach(_.copyTo(targetDir))
      } yield ()
    }

    override def exists(): Boolean = {
      if ( nioPath.toFile.exists() ) {
        attributes().isDirectory
      } else {
        false
      }
    }

  }

  def zioDefer[A](thunk: => A): Task[A] =
    zio.ZIO
      .attemptBlocking(
        scala.util.Try(
          thunk
        )
      )
      .flatMap {
        case scala.util.Success(v) =>
          zsucceed(v)
        case scala.util.Failure(th) =>
          zfail(th)
      }

}
